const t=JSON.parse('{"key":"v-725443d5","path":"/demo/Java_basic.html","title":"java代理模式","lang":"en-US","frontmatter":{"description":"java代理模式 JDK自带的动态代理 就 Java 来说，动态代理的实现方式有很多种，比如 JDK 动态代理、CGLIB 动态代理等等。 JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。因为通过JDK Proxy 方法创建的代理对象都会继承 Proxy 类，通过继承 Proxy 类将 InvocationHandler 与代理对象进行绑定。之后在通过实现代理服务的接口完成对目标对象的增强。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/my-docs/demo/Java_basic.html"}],["meta",{"property":"og:site_name","content":"Blog Demo"}],["meta",{"property":"og:title","content":"java代理模式"}],["meta",{"property":"og:description","content":"java代理模式 JDK自带的动态代理 就 Java 来说，动态代理的实现方式有很多种，比如 JDK 动态代理、CGLIB 动态代理等等。 JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。因为通过JDK Proxy 方法创建的代理对象都会继承 Proxy 类，通过继承 Proxy 类将 InvocationHandler 与代理对象进行绑定。之后在通过实现代理服务的接口完成对目标对象的增强。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://mister-hope.github.io/my-docs/"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2023-03-27T12:22:38.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"java代理模式"}],["meta",{"property":"article:modified_time","content":"2023-03-27T12:22:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"java代理模式\\",\\"image\\":[\\"https://mister-hope.github.io/my-docs/\\"],\\"dateModified\\":\\"2023-03-27T12:22:38.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":1,"title":"java代理模式","slug":"java代理模式","link":"#java代理模式","children":[]}],"git":{"createdTime":1679919111000,"updatedTime":1679919758000,"contributors":[{"name":"hy","email":"boy_hu@126.com","commits":2}]},"readingTime":{"minutes":4.01,"words":1202},"filePathRelative":"demo/Java_basic.md","localizedDate":"March 27, 2023","excerpt":"<h1> java代理模式</h1>\\n<h2> JDK自带的动态代理</h2>\\n<p>就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等等。</p>\\n<p><strong>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类</strong>。因为通过JDK Proxy 方法创建的代理对象都会继承 Proxy 类，通过继承 Proxy 类将 <code>InvocationHandler</code> 与代理对象进行绑定。之后在通过实现代理服务的接口完成对目标对象的增强。</p>","autoDesc":true}');export{t as data};
