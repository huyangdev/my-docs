import{_ as a,W as e,X as t,a0 as o,Y as n,Z as s,a1 as c}from"./framework-b5ea9e64.js";const p="/my-docs/assets/2243690-9cd9c896e0d512ed-cb753027.gif",i="/my-docs/assets/image-20230401215609026-c19a5b94.png",l="/my-docs/assets/image-20230401223806207-5b8d8d71.png",d={},u=n("p",null,[s("部署 "),n("code",null,"Vuepress"),s(" 项目到 "),n("code",null,"Github Page"),s(" 上，并且使用 "),n("code",null,"Vuepress-theme-hope"),s(" 主题。")],-1),r=n("p",null,[s("对"),n("code",null,"java"),s("的集合部分做一个面试的整理")],-1),k=c('<p>下面是一张集合的架构图（来源菜鸟教程）。</p><figure><img src="'+p+'" alt="整个集合的架构图" tabindex="0" loading="lazy"><figcaption>整个集合的架构图</figcaption></figure><h1 id="list" tabindex="-1"><a class="header-anchor" href="#list" aria-hidden="true">#</a> List</h1><h1 id="set" tabindex="-1"><a class="header-anchor" href="#set" aria-hidden="true">#</a> Set</h1><h3 id="hashset、linkedhashset-和-treeset-三者的异同" tabindex="-1"><a class="header-anchor" href="#hashset、linkedhashset-和-treeset-三者的异同" aria-hidden="true">#</a> HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><ul><li>相同：都是Set接口的子类，保证元素唯一。其中<code>HashSet</code>与<code>LinkedHashSet</code>都是都是通过<code>HashMap</code>来实现的。<code>LinkedHashSet</code>继承于<code>HashSet</code>最终实现是基于<code>LinkedHashMap</code>而<code>LinkedHashMap</code>还是基于<code>HashMap</code>实现。</li><li>不同：<code>HashSet</code>的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li></ul><figure><img src="'+i+'" alt="继承结构" tabindex="0" loading="lazy"><figcaption>继承结构</figcaption></figure><h1 id="collection-子类-queue" tabindex="-1"><a class="header-anchor" href="#collection-子类-queue" aria-hidden="true">#</a> Collection 子类 Queue</h1><h2 id="queue-与-deque-的区别" tabindex="-1"><a class="header-anchor" href="#queue-与-deque-的区别" aria-hidden="true">#</a> Queue 与 Deque 的区别</h2><p>Queue是单端队列，Deque是双端队列。</p><h2 id="arraydeque-与-linkedlist-的区别" tabindex="-1"><a class="header-anchor" href="#arraydeque-与-linkedlist-的区别" aria-hidden="true">#</a> ArrayDeque 与 LinkedList 的区别</h2><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p><ul><li><code>ArrayDeque</code> 是<strong>基于可变长的数组</strong>和<strong>双指针</strong>来实现，而 <code>LinkedList</code> 则通过<strong>链表</strong>来实现。</li><li><code>ArrayDeque</code> <strong>不支持</strong>存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li><li><code>ArrayDeque</code> 是在 <strong>JDK1.6</strong> 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul><h2 id="priorityqueue" tabindex="-1"><a class="header-anchor" href="#priorityqueue" aria-hidden="true">#</a> PriorityQueue</h2><p><code>PriorityQueue</code> 是在 <strong>JDK1.5</strong> 中被引入的, 其与 <code>Queue</code> 的区别在于元素<strong>出队顺序是与优先级相关</strong>的，即总是优先级最高的元素先出队。</p><p>这里列举其相关的一些要点：</p><ul><li><code>PriorityQueue</code> 利用了<strong>二叉堆</strong>的数据结构来实现的，底层使用<strong>可变长的数组</strong>来存储数据</li><li><code>PriorityQueue</code> 通过<strong>堆元素的上浮和下沉</strong>，实现了在 <strong>O(logn)</strong> 的时间复杂度内插入元素和删除堆顶元素。</li><li><code>PriorityQueue</code> 是<strong>非线程安全</strong>的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li><li><code>PriorityQueue</code> 默认是<strong>小顶堆</strong>，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li></ul><h1 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> Map</h1><h2 id="hashmap-与-hashtable" tabindex="-1"><a class="header-anchor" href="#hashmap-与-hashtable" aria-hidden="true">#</a> HashMap 与 HashTable</h2><ul><li>线程安全</li></ul><p><code>HashMap</code> 是线程不安全的。<code>HashTable</code>（基本淘汰） 是线程安全的。如果需要使用线程安全的 <code>HashMap</code> 可以直接使用 <code>ConcurrentHashMap</code>。</p><ul><li>效率</li></ul><p>由于线程安全方面的因素，<code>HashMap</code> 要比 <code>HashTable</code> 快</p><ul><li>对 Null key 与 Null value 的支持</li></ul><p><code>HashMap</code> 可以存储 Null 的 Key 与 value，但 null 作为键只能有一个，null 作为值可以有多。</p><p><code>HashTable</code> 不支持Null</p><ul><li>初始容量与扩容机制</li></ul><ol><li>创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 <strong>11</strong>，之后每次扩充，容量变为原来的 <strong>2n+1</strong>。<code>HashMap</code> 默认的初始化大小为 <strong>16</strong>。之后每次扩充，容量变为原来的 <strong>2 倍</strong>。</li><li>创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其<strong>扩充为 2 的幂次方大小</strong>（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 <strong>2 的幂</strong>作为哈希表的大小，后面会介绍到为什么是 2 的幂次方。</li></ol><ul><li>底层数据结构</li></ul><p><strong>JDK1.8</strong> 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为<strong>红黑树</strong>（将链表转换成红黑树前会判断，如果当前数组的<strong>长度小于 64</strong>，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。<code>Hashtable</code> 没有这样的机制。</p><h2 id="hashmap-和-hashset-区别" tabindex="-1"><a class="header-anchor" href="#hashmap-和-hashset-区别" aria-hidden="true">#</a> HashMap 和 HashSet 区别</h2><table><thead><tr><th><strong>HashMap</strong></th><th>HashSet</th></tr></thead><tbody><tr><td>实现了Map接口</td><td>实现了Set接口</td></tr><tr><td>存储键值对</td><td>仅存储键对象，通过键的hash值判别唯一</td></tr><tr><td>调用put（）添加元素</td><td>调用add添加元素</td></tr><tr><td>HashMap<code>使用键（Key）计算</code>hashcode</td><td><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td></tr></tbody></table><h2 id="hashmap-和-treemap-区别" tabindex="-1"><a class="header-anchor" href="#hashmap-和-treemap-区别" aria-hidden="true">#</a> HashMap 和 TreeMap 区别</h2><p>但凡是 <code>TreeXXX</code> 基本都是继承于 <code>NavigableXXX</code>。而<code>NavigableXXX</code>基本继承 <code>SortedXXX</code>。</p><p>比如 <code>TreeSet</code>：</p><figure><img src="'+l+`" alt="TreeSet继承关系图" tabindex="0" loading="lazy"><figcaption>TreeSet继承关系图</figcaption></figure><p><code>TreeMap</code>与之类似，实现了<code>NavigableMap</code>与<code>SrotedMap</code>。实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@author</span> shuang.kou
 * <span class="token keyword">@createTime</span> 2020年06月15日 17:02:00
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Integer</span> age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> treeMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Person</span> person1<span class="token punctuation">,</span> <span class="token class-name">Person</span> person2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> num <span class="token operator">=</span> person1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> person2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;person1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;person2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;person3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;person4&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        treeMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>personStringEntry <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>personStringEntry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Output：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>person1
person4
person2
person3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="hashmap-的长度为什么是-2-的幂次方" tabindex="-1"><a class="header-anchor" href="#hashmap-的长度为什么是-2-的幂次方" aria-hidden="true">#</a> HashMap 的长度为什么是 2 的幂次方</h2><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。</p>`,42);function h(m,g){return e(),t("div",null,[u,r,o(" more "),k])}const b=a(d,[["render",h],["__file","Java_collection.html.vue"]]);export{b as default};
